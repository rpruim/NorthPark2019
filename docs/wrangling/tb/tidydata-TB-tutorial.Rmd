---
title: "Tidying up a data set: A Case Study with TB data"
author: "Randall Pruim"
output: learnr::tutorial
runtime: shiny_prerendered
---

<style type="text/css">

@media screen and (max-width: 1800px) {
  .topics {
    width: 99%;
  }

  .topics .tutorialTitle {
    display: block;
    cursor: pointer;
  }

  .topicsContainer {
    width: 1%;
    min-width: 1px;
    margin-right: 0;
  }

  .topicsList {
    padding: 0px 10px 20px 1%;
    background-color: rgba(255, 255, 255, 0.98);

    box-shadow: 0 5px 25px 0px rgba(0, 0, 0, 0.15);
    -webkit-box-shadow: 0 5px 25px 0px rgba(0, 0, 0, 0.15);
  }

  .topicsList.hideFloating {
    display: none;
  }

  .paneCloser {
    display: inline-block;
  }
}
</style>

```{r setup, include = FALSE}
library(learnr)
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(
  echo = TRUE, tidy = FALSE, size = "small",
  fig.width = 8, fig.height = 6)

library(mosaic)
library(ggformula)
library(tidyr)
library(readr)

theme_set(theme_bw())

data(who, package = "tidyr")
data(population, package = "tidyr")

population2 <-
  population %>%
      mutate(
        country = case_when(
          country == "Curaçao"       ~ "Curacao",
          country == "Côte d'Ivoire" ~ "Cote d'Ivoire",
          TRUE                       ~ country
        ) 
      )
```


## Tidy Data 

### Structure of tidy data

- rows (cases/observational units) and 

- columns (variables).  

- The key is that *every* row is a case and *every* column is a variable.  

- No exceptions.

### But what should the rows be?

That depends on the purpose.

  * For plotting, we often want "glyph ready data" 
    - one row per glyph that gets drawn
    - columns contain variables that get mapped to attributes
    
  * The answer may be different at different points in an analysis (or for different
  layers in the same plot)

You should always know what the rows represent.

## Case Study: Tidying up WHO data

### The Data

The `who` data set in the `tidyr` package contains data from the
World Health Organization Global Tuberculosis Report for 1995-2013.
You can find out more about this data at
[http://www.who.int/tb/country/data/download/en/](http://www.who.int/tb/country/data/download/en/)

```{r, who-data-who, exercise = TRUE}
data(who, package = "tidyr")
inspect(who)
```

The  `population` data set contains global populations from 1980 to 2013.

```{r, who-data-population, exercise = TRUE}
data(population, package = "tidyr")
inspect(population)
```

### An Inconvenient Form: Data in variables

For many purposes, the WHO data are in an inconvenient format.
Each variable `new_sp_m014` through `newrel_f65`
counts the number of new TB cases of a certain kind recorded in a given country, in a given year.
The documentation says the variable names are constructed as follows: 

  * They all begin `new`
  
  * The next bit is a code for the method of diagnosis
  
    * `rel` = relapse, 
    `sn` = negative pulmonary smear, 
    `sp` = positive pulmonary smear, 
    `ep` = extrapulmonary 
    * Note: The separating `_` is missing for `rel` but present for the others.
    
  * After another `_` there is a `m` or an `f` for male or female
  
  * This is followed directly by an age code
  
    * 014 = 0-14 yrs of age, 1524 = 15-24 years of age, 2534 = 25 to 34 years of age,
      3544 = 35 to 44 years of age, 4554 = 45 to 54 years of age, 
      5564 = 55 to 64 years of age, 65 = 65 years of age or older

This format is sometimes called **data-in-variables** format, since some of the information
that we might think of as data values is stored in the names of the variables.

#### Discussion

For what purposes might this be tidy data?

#### Exercises

1. How many countries are in each data set (`who` and `population`)?

```{r, who-countries, exercise = TRUE}
# put your code here to answer the question
```

```{r, who-countries-solution}
who %>% 
  group_by(country) %>%
  summarise(n = n()) %>% 
  mutate(id = n():1)
population %>% 
  group_by(country) %>%
  summarise(n = n()) %>% 
  mutate(id = n():1)
```

2. What countries are listed in one data set but not in the other?

```{r, mismatch-countries, exercise = TRUE}
# put your code here to answer the question
```

```{r, mismatch-countries-solution, include = FALSE}
## There are a number of ways to do this. This gives us some additional useful information.

bind_cols(
  who %>% 
    group_by(country) %>%
    summarise(n = n()) %>% 
    mutate(id = n():1),
  population %>% 
    group_by(country) %>%
    summarise(n = n()) %>% 
    mutate(id = n():1)
) %>%
  filter(country != country1 | id != id1)
```

```{r, mismatch-countries-solution2, include = FALSE}
## There are a number of ways to do this. This uses 
## * anti_join() to find the rows that cannot be matched by country
## * pull() to grab only the country variable
## * unique() to list each country only once

who %>% anti_join(population, by = "country") %>% pull(country) %>% unique()
population %>% anti_join(who, by = "country") %>% pull(country) %>% unique()
```

## Reshaping the data.

**Goal:**

  * row = a person group in a given year and country
  
  * person group described by variables 
  `country`, `iso2`, `iso3`, `year`, `sex`, `diagnosis`, `age_group`
    
  * additional variable:  `count` = number of cases

This format is good for many purposes (including subsequent reshaping and tidying).

## Fixing inconsistent variable names

Let start by making the naming scheme a bit more uniform.  We will replace 
`newrel` with `new_rel`.


```{r, names, exercise = TRUE}
who %>% 
  setNames(sub("newrel", "new_rel", names(.))) %>% 
  names()
```

## pivot_longer()

`pivot_longer()` is used to convert the names and values of multiple columns 
into multiple two-column rows. In each pair, one column will contain
the original names (`names_to`) and the other will contain the original values
(`values_to`).

Here is a demonstration using just the 2000 observations from the USA.

```{r, usa, exercise = TRUE}
who %>% 
  setNames(sub("newrel", "new_rel", names(.))) %>% 
  filter(iso3 == "USA", year == 2000)
```

```{r, usa-pivot-longer, exercise = TRUE}
who %>% 
  setNames(sub("newrel", "new_rel", names(.))) %>% 
  filter(iso3 == "USA", year == 2000) %>%
  pivot_longer(names_to = "code", values_to = "new_cases", matches("new"))
```

Notice how columns 5 - 60 (the ones that include "new" in their names)
turned into two columns (`code` and `new_cases`). 
Columns 1 - 4, which were not included in our list of columns, were duplicated.

If we omit the `filter()` command, we can process the entire data set.

```{r, who-pivot-longer, exercise = TRUE}
who %>% 
  setNames(sub("newrel", "new_rel", names(.))) %>% 
  pivot_longer(names_to = "code", values_to = "new_cases", matches("new"))
```

**Note:** The inverse operation to `pivot_loger()` is called `pivot_wider()`. 
It takes a pair of columns
and turns one column into variable names (`names_from`) and the other into values
(`values_from`).

## separate()

Now we need to separate our `code` column into separate columns, one for each piece of information coded.

```{r, who-separate, exercise = TRUE}
who %>% 
  setNames(sub("newrel", "new_rel", names(.))) %>% 
  pivot_longer(names_to = "code", values_to = "new_cases", matches("new")) %>%
  separate(code, c("status", "diagnosis", "sexage"), sep = "_")
```

And subsequently we can separate the sex from the age group using position rather than a character
to do the separation. 

```{r, who-separate2, exercise = TRUE}
who %>% 
  setNames(sub("newrel", "new_rel", names(.))) %>% 
  pivot_longer(names_to = "code", values_to = "new_cases", matches("new")) %>%
  separate(code, c("status", "diagnosis", "sexage"), sep = "_") %>%
  separate(sexage, c("sex", "age_group"), sep = 1)
```

**Note:** The inverse operation of `separate()` is `unite()`.  (`paste()` is often useful as well.)

#### Exercises

1. Add on some additional code to check that things are working.

  * Show that the only values of `sex` are `m` and `f` and that they appear in equal numbers.
  * Do a similar thing for the diagnosis groups and age groups

```{r, who-separate3, exercise = TRUE}
who %>% 
  setNames(sub("newrel", "new_rel", names(.))) %>% 
  pivot_longer(names_to = "code", values_to = "new_cases", matches("new")) %>%
  separate(code, c("status", "diagnosis", "sexage"), sep = "_") %>%
  separate(sexage, c("sex", "age_group"), sep = 1) 
```

```{r who-separate3-solution}
# here is the solution for checking that we have equal numbers of males and females.
# you can 
who %>% 
  setNames(sub("newrel", "new_rel", names(.))) %>% 
  pivot_longer(names_to = "code", values_to = "new_cases", matches("new")) %>%
  separate(code, c("status", "diagnosis", "sexage"), sep = "_") %>%
  separate(sexage, c("sex", "age_group"), sep = 1) %>%
  group_by(sex) %>%
  summarise(n = n())
```


2. Construct a plot that shows the total number of new TB cases over time for
each country. 

```{r, who-separate-plot, exercise = TRUE}
who %>% 
  setNames(sub("newrel", "new_rel", names(.))) %>% 
  pivot_longer(names_to = "code", values_to = "new_cases", matches("new")) %>%
  separate(code, c("status", "diagnosis", "sexage"), sep = "_") %>%
  separate(sexage, c("sex", "age_group"), sep = 1) 
```

3. That's a lot of countries.  Perhaps you might like to remake the plot using
only a subset of countries. Which countries?
 

```{r, who-separate-plot2, exercise = TRUE}
who %>% 
  setNames(sub("newrel", "new_rel", names(.))) %>% 
  pivot_longer(names_to = "code", values_to = "new_cases", matches("new")) %>%
  separate(code, c("status", "diagnosis", "sexage"), sep = "_") %>%
  separate(sexage, c("sex", "age_group"), sep = 1) 
```

```{r, who-separate-plot2-solution}
# Note:  This will be more useful once we can scale by total population
who %>% 
  setNames(sub("newrel", "new_rel", names(.))) %>% 
  pivot_longer(names_to = "code", values_to = "new_cases", matches("new")) %>%
  separate(code, c("status", "diagnosis", "sexage"), sep = "_") %>%
  separate(sexage, c("sex", "age_group"), sep = 1) %>%
  group_by(country, iso3, year) %>%
  summarise(total_cases = sum(new_cases, na.rm = TRUE)) %>%
  filter(iso3 %in% c("USA", "IND", "CHN", "NGA", "DEU", "GHA")) %>% 
  gf_line(total_cases ~ year, color = ~country)
```

## Joins

### Comparing TB cases to population

More interesting than the number of TB cases is the fraction of the population that is contracting TB.

  * `who` data does not include population.
  * the `population` data has population information, but nothing about TB
  
We need to join these data sets together so we can compute the TB rate for each country (in each year).

Both data sets have a `country` variable that we can use to match things up between data sets.

* We will consider our modified `who` data to be primary data 
and add in population information from `population`.
  
* Unfortunately, two country names are spelled differently in `who` and
`population`, so we will need to address this before joining.

### The join functions

`dplyr` has a number of functions with "join" in the name that are used to bring
data from two sources together into one.  The basic syntax is

```{r, eval = FALSE}
LeftData %>% 
  some_join(RightData, ...)
```

where `some_join()` is one of 

 * `inner_join()`: return all rows from `LeftData` where there are matching values in `Data2`, and all columns from `LeftData` and `RightData`. If there are multiple matches between `LeftData` and `RightData`, all combination of the matches are returned.

 * `left_join()`:
return all rows from `LeftData`, and all columns from `LeftData` and `RightData`. Rows in `LeftData` with no match in `RightData` will have NA values in the new columns. If there are multiple matches between `LeftData` and `RightData`, all combinations of the matches are returned.

 * `right_join()`:
return all rows from `RightData`, and all columns from `LeftData` and `RightData`. Rows in `RightData` with no match in `LeftData` will have NA values in the new columns. If there are multiple matches between `LeftData` and `RightData`, all combinations of the matches are returned.

 * `semi_join()`:
return all rows from `LeftData` where there are matching values in `RightData`, keeping just columns from `LeftData`.  A semi join differs from an inner join because an inner join will return one row of `LeftData` for each matching row of `RightData`, where a semi join will never duplicate rows of `LeftData`.

 * `anti_join()`:
return all rows from `LeftData` where there are not matching values in `RightData`, keeping just columns from `LeftData`.

`full_join()`:
return all rows and all columns from both `LeftData` and `RightData`. Where
there are not matching values, returns NA for the one missing.

### Using anti_join() to detect joining pro

```{r anti-join, exercise = TRUE}
who %>% 
  anti_join(population, by = "country") %>% 
  group_by(country) %>%
  summarise(n = n())

population %>% 
  anti_join(who, by = "country") %>% 
  group_by(country) %>%
  summarise(n = n())
```

We can recode the countries in `population` to match the names in
`who` using `tidyr::case_when()`.

```{r, country-rename, exercise = TRUE}
who %>%
  anti_join(by = "country", 
    population %>%
      mutate(
        country = case_when(
          country == "Curaçao"       ~ "Curacao",
          country == "Côte d'Ivoire" ~ "Cote d'Ivoire",
          TRUE                       ~ country
        ) 
      )
  ) %>%
  nrow()
```

Let's save this with a new name so we can reuse it below.

```{r}
population2 <-
  population %>%
      mutate(
        country = case_when(
          country == "Curaçao"       ~ "Curacao",
          country == "Côte d'Ivoire" ~ "Cote d'Ivoire",
          TRUE                       ~ country
        ) 
      )
```

We want a `left_join()` of our modified `who` data with the `population` data.
By default, matching is on all columns that have the same names.  That works
just right for us in this case.  When the columns for matching have different
names, there are ways to specify which names in `LeftData` correspond with which
names in `RightData` (or we can rename the variables to make them match).

A message is displayed to show which variables were used for matching.  It's
good to check that those are what you expect.

```{r, who-join, exercise = TRUE}
who %>% 
  setNames(sub("newrel", "new_rel", names(.))) %>% 
  pivot_longer(names_to = "code", values_to = "new_cases", matches("new")) %>%
  separate(code, c("status", "diagnosis", "sexage"), sep = "_") %>%
  separate(sexage, c("sex", "age_group"), sep = 1) %>%
  left_join(population2)
```

#### Exercise

Use the joined data below to make a plot showing the distribution of TB rates.

```{r, who-TB-rate-plot, exercise = TRUE}
who %>% 
  setNames(sub("newrel", "new_rel", names(.))) %>% 
  pivot_longer(names_to = "code", values_to = "new_cases", matches("new")) %>%
  separate(code, c("status", "diagnosis", "sexage"), sep = "_") %>%
  separate(sexage, c("sex", "age_group"), sep = 1) %>%
  left_join(population2)
```

```{r, who-TB-rate-plot-solution}
who %>% 
  setNames(sub("newrel", "new_rel", names(.))) %>% 
  pivot_longer(names_to = "code", values_to = "new_cases", matches("new")) %>%
  separate(code, c("status", "diagnosis", "sexage"), sep = "_") %>%
  separate(sexage, c("sex", "age_group"), sep = 1) %>%
  left_join(population2) %>% 
  group_by(country, year) %>%
  summarise(
    total_cases = sum(new_cases, na.rm = TRUE),
    tb_rate = total_cases / max(population)
  ) %>% 
  filter(year == 2010) %>%
  gf_dens(~ tb_rate)
```

#### Exercise

 1. Use the joined data below to locate the ten countries with the highest average TB rate over the 
years for which they reported data.

 2. Plot the TB rates over time for these ten countries.

```{r, who-top-tb-rate, exercise = TRUE}
who %>% 
  setNames(sub("newrel", "new_rel", names(.))) %>% 
  pivot_longer(names_to = "code", values_to = "new_cases", matches("new")) %>%
  separate(code, c("status", "diagnosis", "sexage"), sep = "_") %>%
  separate(sexage, c("sex", "age_group"), sep = 1) %>%
  left_join(population2)
```

```{r, who-top-tb-rate-solution}
who %>% 
  setNames(sub("newrel", "new_rel", names(.))) %>% 
  pivot_longer(names_to = "code", values_to = "new_cases", matches("new")) %>%
  separate(code, c("status", "diagnosis", "sexage"), sep = "_") %>%
  separate(sexage, c("sex", "age_group"), sep = 1) %>%
  left_join(population2) %>% 
  group_by(country, iso3, year) %>%
  summarise(
    total_cases = sum(new_cases, na.rm = TRUE),
    tb_rate = total_cases / max(population)
  ) %>% 
  group_by(country, iso3) %>%
  mutate(mean_tb_rate = mean(tb_rate, na.rm = TRUE)) %>%
  ungroup() %>%
  arrange(-mean_tb_rate) %>%
  head(10 * (2013 - 1979)) %>%
  gf_line(tb_rate ~ year, color = ~ iso3) %>% 
  gf_lims(x = c(1990, NA))
```

## A few other things

We didn't need them in this case study, but here are some additional functions
that can be useful for tidying up your data.

#### Extracting values from text 

`readr::parse_number()`, `readr::parse_integer()`, `readr::parse_date()`, etc.:
These functions read through the values in a variable and do there best to
extract the type of information requested. The R ingestion functions will
typically turn what you expect to be numeric values into text if there are any
values that it cannot interpret as a number.  So this can be very handy when
bringing in data created in other software.

#### Exercises

 1. Enter some other types of text to see how `parse_number()` converts things.
 
 2. Try changing `parse_number()` to one of the other parsers.

```{r, parse-number, exercise = TRUE}
library(readr)
parse_number(
  c("123", "A53", ".53", "123-456", "$5.47", 
    "95 degrees F", "-", "missing data"))
```

 3. Add `na = c("", "-")` to the `parse_number()` call above. What does that do?
 
 4. Dates are tricky because there are so many formats, and a date can be
 ambiguous without knowledge of the format used.  (What date is 10-11-12?)
 `lubridate()` provides functions like `mdy()`, `ymd()`, etc. that allow us to
 specify the order of year, month, and day.  (Add `hms` if you also have times
 to process.)  Edit `some_dates` below to see what formats are correctly parsed.

 
```{r, parse-date, exercise = TRUE}
library(lubridate)
some_dates <- c("17-july-2019", "1-2-3", "1-2-03", "1/2/3", "01/02/03")
dmy(some_dates)
mdy(some_dates)
ymd(some_dates)
```

The `lubridate` package has many other utilities for working with dates and times.


<!-- #### Human names -->

<!-- The `humanparser` package has tools for extracting people's names and figuring out first, -->
<!-- middle and last names. -->

<!-- ```{r, parse-names, exercise = TRUE} -->
<!-- library(humanparser) -->
<!-- full_names <- c("David Regan", "Izaque Iuzuru Nagata", "Rip Van Winkle", -->
<!--                 "Christian Schmit de la Breli", "Peter Doyle", "Hans R. Bruetsch", -->
<!--                 "Marcus Reichel", "Per-Axel Koch", "Louis Van der Walt", -->
<!--                 "Mary Ellen Rudin", "Mario Adamek", "Ugur Tozsekerli",  -->
<!--                 "Judit Ludvai") -->
<!-- humanparser::parse_names(full_names) -->
<!-- ``` -->

<!--  * `dplyr::bind_rows()`, `dplyr::bind_cols()`: These functions paste data frames together one below the other -->
<!--  or one next to the other -- provided the data frames are appropriately conformable. -->

